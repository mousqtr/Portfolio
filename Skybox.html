<!DOCTYPE html>
<html>
  <head>
    <meta charset=UTF-8 />
    <title>Titre de la page</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <canvas id="c"></canvas>


    <!-- <script src="three.js"></script> -->
    <!-- <script src="OrbitControls.js"></script> -->
    
    <script type="module"> 
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
        import {GLTFLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/GLTFLoader.js';
        import {FBXLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/FBXLoader.js';

        let scene, camera, renderer;
        
        window.addEventListener( 'resize', onWindowResize, false );

        function onWindowResize(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );

            if (objects.length > 0){
              let distance;
              for (let i = 0; i < objects.length; i++) {
                switch(objects[i].position.x){
                  case 500:
                    distance = 0.67 * window.innerWidth - 2333;
                    objects[i].position.set(500, -500, distance);
                    console.log("char")
                    break;
                  case 0:
                    distance = 0.375 * window.innerWidth - 1150;
                    distance = Math.min(-600, distance);
                    distance = Math.max(-1000, distance);
                    objects[i].position.set(0, -500, distance);
                    console.log("door")
                    break;
                  default:
                    break;
                }
              }
            }
                  

        }

        
        const canvas = document.querySelector('#c');

        scene = new THREE.Scene();
        const fov = 55; // field of view
        const aspect = window.innerWidth/window.innerHeight;  // the canvas default
        const near = 45;
        const far = 30000;
        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0,0,0);
        
        renderer = new THREE.WebGLRenderer({antialias:true, canvas});
        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let controls = new OrbitControls(camera, renderer.domElement );
        controls.addEventListener('change', renderer);
        controls.minDistance = 500;
        controls.maxDistance = 1500;
        
        let materialArray = [];
        let texture_ft = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_bk = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_up = new THREE.TextureLoader().load( 'img/wall3.jpg');
        let texture_dn = new THREE.TextureLoader().load( 'img/parquet.jpg');
        let texture_rt = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_lf = new THREE.TextureLoader().load( 'img/wall2.jpg');

        texture_dn.wrapS = texture_dn.wrapT = THREE.RepeatWrapping;
        texture_dn.repeat.y = 5;

        texture_up.wrapS = texture_up.wrapT = THREE.RepeatWrapping;
        texture_up.repeat.y = 5;

        texture_ft.wrapS = texture_ft.wrapT = THREE.RepeatWrapping;
        texture_ft.repeat.x = 5;

        texture_bk.wrapS = texture_bk.wrapT = THREE.RepeatWrapping;
        texture_bk.repeat.x = 5;

        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));

        for (let i = 0; i < 6; i++) {
            materialArray[i].side = THREE.BackSide;
        }
            

        let skyboxGeo = new THREE.BoxGeometry( 1000, 1000, 10000);
        let skybox = new THREE.Mesh( skyboxGeo, materialArray );
        skybox.position.set(0, 0, -4500)
        scene.add( skybox );  

        let geom = new THREE.BoxGeometry( 50, 50, 50);
        let mat = new THREE.MeshBasicMaterial();
        mat.color.setRGB( 1, 0, 0 );
        let cube = new THREE.Mesh( geom, mat );
        cube.position.set(0, 200, -500)
        scene.add( cube );  


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove( event ) {
          mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
          mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }
        

        window.addEventListener( 'mousemove', onMouseMove, false );

        const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 0, 0 );
				scene.add( hemiLight );

        const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( 0, 0, 100 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 180;
				dirLight.shadow.camera.bottom = - 100;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );

        let mixers = [];
        const clock = new THREE.Clock();

        var objects = []
        var actions = []
        var anims = []

        const loader = new FBXLoader();
        loader.load('models/paladin/paladin.fbx', (object) => {

          object.scale.setScalar(3);
          object.position.set(0, -500, -600)
          object.rotation.set(0, Math.PI, 0)
          object.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          objects.push(object)

          const anim1 = new FBXLoader();
          anim1.load('models/paladin/walk.fbx', (anim1) => {
            const mixer = new THREE.AnimationMixer( object );
            mixers.push(mixer)
            const action = mixer.clipAction( anim1.animations[0] );
            // action.play();
            actions.push(action);
            anims.push(anim1.animations[0]);
          });
          

          const anim2 = new FBXLoader();
          anim2.load('models/paladin/stand_brief.fbx', (anim2) => {
            const mixer = new THREE.AnimationMixer( object );
            mixers.push(mixer)
            const action = mixer.clipAction( anim2.animations[0] );
            action.play();
            actions.push(action);
            anims.push(anim2.animations[0]);
          });
          anims.push(anim2);

          

          scene.add(object);
        });

        

        
        const loader2 = new FBXLoader();
        loader2.load('models/door.fbx', (door) => {

          door.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          door.scale.setScalar(0.3);
          let distance_door = 0.67 * window.innerWidth - 2333;
          door.position.set(500, -500, distance_door);
          door.rotation.set(0, Math.PI/2, 0);

          objects.push(door)

          scene.add(door);
        });
        

        
        

        animate();


        

        function animate() {
            
            // scene.rotation.y += 0.01; 
            // scene.position.z += 1; 

            // update the picking ray with the camera and mouse position
            raycaster.setFromCamera( mouse, camera );

            // calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects( scene.children );

            for ( let i = 0; i < intersects.length; i ++ ) {
              if (intersects[0].object == cube){
                cube.rotation.y += 0.5
                
                if (mixers.length > 0){
                  actions[0].play();
                  if(actions[1].isRunning()){
                    actions[1].stop();
                    actions[0].play();
                  }
                }
    
              }else{
                if (mixers.length > 0){
                  if(actions[0].isRunning()){
                    actions[0].stop();
                    actions[1].play();
                  }

                }
                  
              }
            }

            const delta = clock.getDelta();

            for ( let i = 0; i < mixers.length; i ++ ) {
              if ( mixers[i] ) mixers[i].update( delta );
            }

            
            requestAnimationFrame(animate);

            renderer.render(scene,camera);
            
        }




    </script>
  </body>
</html>