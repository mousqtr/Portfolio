<!DOCTYPE html>
<html>
  <head>
    <meta charset=UTF-8 />
    <title>Titre de la page</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <canvas id="c"></canvas>
    
    <script type="module"> 
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
        import {GLTFLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/GLTFLoader.js';
        import {FBXLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/FBXLoader.js';

        let scene, camera, renderer;
        
        const clock = new THREE.Clock();
        let objects = {};
        let actions = {};
        let mixers = {};
        let movement = 0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'click', onClick, false );

        function onWindowResize(){
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );

          if (Object.keys(objects).length > 0){
            let distance;
            
            // Paladin
            distance = 0.375 * window.innerWidth - 1150;
            distance = Math.min(-600, distance);
            distance = Math.max(-1000, distance);
            objects["paladin"].position.set(0, -500, distance);
          
            // Door
            distance = 0.67 * window.innerWidth - 2333;
            objects["door"].position.set(500, -500, distance);

            // Text above door
            distance = 0.67 * window.innerWidth - 2500;
            objects["textDoor"].position.set(400, 270, distance);

          }
                  
        }

        
        const canvas = document.querySelector('#c');

        scene = new THREE.Scene();
        const fov = 55; // field of view
        const aspect = window.innerWidth/window.innerHeight;  // the canvas default
        const near = 45;
        const far = 30000;
        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0,0,0);
        
        renderer = new THREE.WebGLRenderer({antialias:true, canvas});
        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // let controls = new OrbitControls(camera, renderer.domElement );
        // controls.addEventListener('change', renderer);
        // controls.minDistance = 500;
        // controls.maxDistance = 1500;
        
        // Load the corridor
        let corridorMaterialArray = [];
        let texture_ft = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_bk = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_up = new THREE.TextureLoader().load( 'img/wall3.jpg');
        let texture_dn = new THREE.TextureLoader().load( 'img/parquet.jpg');
        let texture_rt = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_lf = new THREE.TextureLoader().load( 'img/wall2.jpg');

        texture_dn.wrapS = texture_dn.wrapT = THREE.RepeatWrapping;
        texture_up.wrapS = texture_up.wrapT = THREE.RepeatWrapping;
        texture_ft.wrapS = texture_ft.wrapT = THREE.RepeatWrapping;
        texture_bk.wrapS = texture_bk.wrapT = THREE.RepeatWrapping;

        texture_dn.repeat.y = 5;
        texture_up.repeat.y = 5;
        texture_ft.repeat.x = 5;
        texture_bk.repeat.x = 5;

        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));

        for (let i = 0; i < 6; i++) {
          corridorMaterialArray[i].side = THREE.BackSide;
        }
            
        let corridorGeo = new THREE.BoxGeometry( 1000, 1000, 10000);
        let corridor = new THREE.Mesh( corridorGeo, corridorMaterialArray );
        corridor.position.set(0, 0, -4500)
        scene.add( corridor );  

        // Load the top arrow 
        const arrowLoader = new FBXLoader();
        arrowLoader.load('models/arrow.fbx', (arrow) => {
          arrow.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
            child.material = new THREE.MeshPhongMaterial( { 
              color: 0xffff00
            } );
          });       
          arrow.scale.setScalar(200);
          arrow.position.set(0, 200, -600);
          arrow.rotation.set(-Math.PI/2, Math.PI, Math.PI/2);
          arrow.name = "arrow";
          objects["arrow"] = arrow;
          scene.add(arrow);
        });

        // Get the mouse position
        function onMouseMove( event ) {
          mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
          mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        // When user click somewhere
        function onClick(event) {
          raycaster.setFromCamera( mouse, camera );
          const intersects = raycaster.intersectObjects( scene.children, true );

          for ( let i = 0; i < intersects.length; i ++ ) {
            if ((intersects[0].object.name == 'Box') || (intersects[0].object.name == 'Box1')){
              
              if (Object.keys(objects).length > 1){
                movement = 1;
              }
            }
          }
        }

        // Hemisphere Light
        const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 0, 0 );
				scene.add( hemiLight );

        // Directional Light
        const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( 0, 0, 100 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 180;
				dirLight.shadow.camera.bottom = - 100;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );

        // Load the paladin model
        const loaderPaladin = new FBXLoader();
        loaderPaladin.load('models/paladin/paladin.fbx', (paladin) => {

          // Load the model
          paladin.scale.setScalar(3);
          paladin.position.set(0, -500, -600)
          paladin.rotation.set(0, Math.PI, 0)
          paladin.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          objects["paladin"] = paladin;

          // Load the walk animation
          const animWalk = new FBXLoader();
          animWalk.load('models/paladin/walk.fbx', (animWalk) => {
            const mixer = new THREE.AnimationMixer(paladin);     
            const action = mixer.clipAction( animWalk.animations[0] );
            mixers["mixerWalk"] = mixer
            actions["walk"] = action;
          });
          
          // Load the stand animation
          const animStand = new FBXLoader();
          animStand.load('models/paladin/stand_brief.fbx', (animStand) => {
            const mixer = new THREE.AnimationMixer(paladin);
            const action = mixer.clipAction(animStand.animations[0]);
            mixers["mixerStand"] = mixer
            actions["stand"] = action;
            action.play();
          });

          scene.add(paladin);
        });

        // Load the door model
        const loaderDoor = new FBXLoader();
        loaderDoor.load('models/door.fbx', (door) => {

          door.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          door.scale.setScalar(0.3);
          let distance_door = 0.67 * window.innerWidth - 2333;
          door.position.set(500, -500, distance_door);
          door.rotation.set(0, Math.PI/2, 0);

          objects["door"] = door;

          scene.add(door);
        });

        // Cube above door
        let geoText = new THREE.BoxGeometry( 300, 200, 50);
        let matText = new THREE.MeshBasicMaterial();
        matText.color.setRGB( 4/255, 47/255, 102/255 );
        let cubeText = new THREE.Mesh( geoText, matText );
        let distance_cube = 0.67 * window.innerWidth - 2500;
        cubeText.position.set(400, 270, distance_cube)
        objects["textDoor"] = cubeText;
        scene.add( cubeText );  
        
        animate();

        function animate() {
            
          if (movement == 0){
            raycaster.setFromCamera( mouse, camera );
            const intersects = raycaster.intersectObjects( scene.children, true );
            for ( let i = 0; i < intersects.length; i ++ ) {

              // Case of the upper arrow
              if ((intersects[0].object.name == 'Box') || (intersects[0].object.name == 'Box1')){
                
                // Change the color of the arrow into red
                if (Object.keys(objects).length > 1){
                  objects["arrow"].traverse(function(child){
                    child.material = new THREE.MeshPhongMaterial( { 
                      color: 0xff0000
                    }); 
                  });
                }

              }else{
                
                // Change the color of the arrow into yellow
                if (Object.keys(objects).length > 1){
                  objects["arrow"].traverse(function(child){
                    child.material = new THREE.MeshPhongMaterial( { 
                      color: 0xffff00
                    }); 
                  });
                } 
              }
            }
          }

          if (movement == 1){
            objects["paladin"].position.z -= 5;

            if (Object.keys(actions).length > 1){
              if(actions["stand"].isRunning()){
                actions["stand"].stop();
                actions["walk"].play();
              }
            }

            camera.position.z -= 5;
          }

          // if ((movement == 1) && (position.z == -2500){
          //   objects[2].position.z -= 5;

          //   if (mixers.length > 0){
          //     if(actions[1].isRunning()){
          //       actions[1].stop();
          //       actions[0].play();
          //     }
          //   }
          // } 

          const delta = clock.getDelta();

          if ( mixers["mixerWalk"] ) mixers["mixerWalk"].update( delta );
          if ( mixers["mixerStand"] ) mixers["mixerStand"].update( delta );
    
          requestAnimationFrame(animate);

          renderer.render(scene,camera);
            
        }


    </script>
  </body>
</html>