<!DOCTYPE html>
<html>
  <head>
    <meta charset=UTF-8 />
    <title>Titre de la page</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <canvas id="c"></canvas>


    <!-- <script src="three.js"></script> -->
    <!-- <script src="OrbitControls.js"></script> -->
    
    <script type="module"> 
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
        import {GLTFLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/GLTFLoader.js';
        import {FBXLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/FBXLoader.js';

        let scene, camera, renderer;
        var objects = {}
        
        window.addEventListener( 'resize', onWindowResize, false );

        function onWindowResize(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );

            if (Object.keys(objects).length > 0){
              let distance;
              for (let i = 0; i < Object.keys(objects).length; i++) {
                // switch(objects[i].position.x){
                //   case 0: 
                //     if (objects[i].position.y == -500){ // Character
                //       distance = 0.375 * window.innerWidth - 1150;
                //       distance = Math.min(-600, distance);
                //       distance = Math.max(-1000, distance);
                //       objects[i].position.set(0, -500, distance);
                //       break;
                //     }
                //     break;
                //   case 500: // Door
                //     distance = 0.67 * window.innerWidth - 2333;
                //     objects[i].position.set(500, -500, distance);
                //     break;
                //   case 400: // Text above door
                //     distance = 0.67 * window.innerWidth - 2500;
                //     objects[i].position.set(400, 270, distance);
                //     break;
                //   default:
                //     break;
                // }
                console.log("ok")
              }
            }
                  

        }

        
        const canvas = document.querySelector('#c');

        scene = new THREE.Scene();
        const fov = 55; // field of view
        const aspect = window.innerWidth/window.innerHeight;  // the canvas default
        const near = 45;
        const far = 30000;
        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0,0,0);
        
        renderer = new THREE.WebGLRenderer({antialias:true, canvas});
        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let controls = new OrbitControls(camera, renderer.domElement );
        controls.addEventListener('change', renderer);
        controls.minDistance = 500;
        controls.maxDistance = 1500;
        
        let materialArray = [];
        let texture_ft = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_bk = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_up = new THREE.TextureLoader().load( 'img/wall3.jpg');
        let texture_dn = new THREE.TextureLoader().load( 'img/parquet.jpg');
        let texture_rt = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_lf = new THREE.TextureLoader().load( 'img/wall2.jpg');

        texture_dn.wrapS = texture_dn.wrapT = THREE.RepeatWrapping;
        texture_dn.repeat.y = 5;

        texture_up.wrapS = texture_up.wrapT = THREE.RepeatWrapping;
        texture_up.repeat.y = 5;

        texture_ft.wrapS = texture_ft.wrapT = THREE.RepeatWrapping;
        texture_ft.repeat.x = 5;

        texture_bk.wrapS = texture_bk.wrapT = THREE.RepeatWrapping;
        texture_bk.repeat.x = 5;

        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));

        for (let i = 0; i < 6; i++) {
            materialArray[i].side = THREE.BackSide;
        }
            



        const arrowLoader = new FBXLoader();
        arrowLoader.load('models/arrow.fbx', (arrow) => {
          arrow.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
            child.material = new THREE.MeshPhongMaterial( { 
              color: 0xffff00
            } );
          });       
          arrow.scale.setScalar(200);
          arrow.position.set(0, 200, -600);
          arrow.rotation.set(-Math.PI/2, Math.PI, Math.PI/2);
          arrow.name = "arrow";
          objects["arrow"] = arrow;
          scene.add(arrow);
        });

        

        let skyboxGeo = new THREE.BoxGeometry( 1000, 1000, 10000);
        let skybox = new THREE.Mesh( skyboxGeo, materialArray );
        skybox.position.set(0, 0, -4500)
        scene.add( skybox );  

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove( event ) {
          mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
          mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        let movement = 0;
        function onClick(event) {
          raycaster.setFromCamera( mouse, camera );
          const intersects = raycaster.intersectObjects( scene.children, true );

          for ( let i = 0; i < intersects.length; i ++ ) {
            if ((intersects[0].object.name == 'Box') || (intersects[0].object.name == 'Box1')){
              
              if (Object.keys(objects).length > 1){
                movement = 1;
              }
            }
          }
        }

        window.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'click', onClick, false );

        const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 0, 0 );
				scene.add( hemiLight );

        const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( 0, 0, 100 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 180;
				dirLight.shadow.camera.bottom = - 100;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );

        let mixers = [];
        const clock = new THREE.Clock();

        var actions = []
        var anims = []

        const loader = new FBXLoader();
        loader.load('models/paladin/paladin.fbx', (object) => {

          object.scale.setScalar(3);
          object.position.set(0, -500, -600)
          object.rotation.set(0, Math.PI, 0)
          object.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          objects["paladin"] = object;

          const anim1 = new FBXLoader();
          anim1.load('models/paladin/walk.fbx', (anim1) => {
            const mixer = new THREE.AnimationMixer( object );
            mixers.push(mixer)
            const action = mixer.clipAction( anim1.animations[0] );
            actions.push(action);
            anims.push(anim1.animations[0]);
          });
          

          const anim2 = new FBXLoader();
          anim2.load('models/paladin/stand_brief.fbx', (anim2) => {
            const mixer = new THREE.AnimationMixer( object );
            mixers.push(mixer)
            const action = mixer.clipAction( anim2.animations[0] );
            action.play();
            actions.push(action);
            anims.push(anim2.animations[0]);
          });
          anims.push(anim2);

          scene.add(object);
        });

        

        const loader2 = new FBXLoader();
        loader2.load('models/door.fbx', (door) => {

          door.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          door.scale.setScalar(0.3);
          let distance_door = 0.67 * window.innerWidth - 2333;
          door.position.set(500, -500, distance_door);
          door.rotation.set(0, Math.PI/2, 0);

          objects["door"] = door;

          scene.add(door);
        });

        let geoText = new THREE.BoxGeometry( 300, 200, 50);
        let matText = new THREE.MeshBasicMaterial();
        matText.color.setRGB( 4/255, 47/255, 102/255 );
        let cubeText = new THREE.Mesh( geoText, matText );
        let distance_cube = 0.67 * window.innerWidth - 2500;
        cubeText.position.set(400, 270, distance_cube)
        objects["cubeText"] = cubeText;
        scene.add( cubeText );  
        

        
        

        animate();



        function animate() {
            

          if (movement == 0){
            raycaster.setFromCamera( mouse, camera );
            const intersects = raycaster.intersectObjects( scene.children, true );
            for ( let i = 0; i < intersects.length; i ++ ) {

              
              if ((intersects[0].object.name == 'Box') || (intersects[0].object.name == 'Box1')){// Case of the upper arrow
                
                // Change the color of the arrow into red
                if (Object.keys(objects).length > 1){
                  objects["arrow"].traverse(function(child){
                    child.material = new THREE.MeshPhongMaterial( { 
                      color: 0xff0000
                    }); 
                  });
                }

              }else{
                
                // Change the color of the arrow into yellow
                if (Object.keys(objects).length > 1){
                  objects["arrow"].traverse(function(child){
                    child.material = new THREE.MeshPhongMaterial( { 
                      color: 0xffff00
                    }); 
                  });
                } 
              }
            }
          }


          if (movement == 1){
            objects["paladin"].position.z -= 5;

            if (mixers.length > 0){
              if(actions[1].isRunning()){
                actions[1].stop();
                actions[0].play();
              }
            }

            camera.position.z -= 5;
          }

          // if ((movement == 1) && (position.z == -2500){
          //   objects[2].position.z -= 5;

          //   if (mixers.length > 0){
          //     if(actions[1].isRunning()){
          //       actions[1].stop();
          //       actions[0].play();
          //     }
          //   }
          // } 

          const delta = clock.getDelta();

          for ( let i = 0; i < mixers.length; i ++ ) {
            if ( mixers[i] ) mixers[i].update( delta );
          }

          
          requestAnimationFrame(animate);

          renderer.render(scene,camera);
            
        }




    </script>
  </body>
</html>