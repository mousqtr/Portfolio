<!DOCTYPE html>
<html>
  <head>
    <meta charset=UTF-8 />
    <title>Titre de la page</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <canvas id="c"></canvas>


    <!-- <script src="three.js"></script> -->
    <!-- <script src="OrbitControls.js"></script> -->
    
    <script type="module"> 
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
        import {GLTFLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/GLTFLoader.js';
        import {FBXLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/FBXLoader.js';

        let scene, camera, renderer;
        
        window.addEventListener( 'resize', onWindowResize, false );

        function onWindowResize(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        
        const canvas = document.querySelector('#c');

        scene = new THREE.Scene();
        const fov = 55; // field of view
        const aspect = window.innerWidth/window.innerHeight;  // the canvas default
        const near = 45;
        const far = 30000;
        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0,0,0);
        
        renderer = new THREE.WebGLRenderer({antialias:true, canvas});
        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let controls = new OrbitControls(camera, renderer.domElement );
        controls.addEventListener('change', renderer);
        controls.minDistance = 500;
        controls.maxDistance = 1500;
        
        let materialArray = [];
        let texture_ft = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_bk = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_up = new THREE.TextureLoader().load( 'img/wall3.jpg');
        let texture_dn = new THREE.TextureLoader().load( 'img/parquet.jpg');
        let texture_rt = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_lf = new THREE.TextureLoader().load( 'img/wall2.jpg');

        texture_dn.wrapS = texture_dn.wrapT = THREE.RepeatWrapping;
        texture_dn.repeat.y = 5;

        texture_up.wrapS = texture_up.wrapT = THREE.RepeatWrapping;
        texture_up.repeat.y = 5;

        texture_ft.wrapS = texture_ft.wrapT = THREE.RepeatWrapping;
        texture_ft.repeat.x = 5;

        texture_bk.wrapS = texture_bk.wrapT = THREE.RepeatWrapping;
        texture_bk.repeat.x = 5;

        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));
        materialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));

        for (let i = 0; i < 6; i++) {
            materialArray[i].side = THREE.BackSide;
        }
            

        let skyboxGeo = new THREE.BoxGeometry( 1000, 1000, 10000);
        let skybox = new THREE.Mesh( skyboxGeo, materialArray );
        skybox.position.set(0, 0, -4500)
        scene.add( skybox );  

        let geom = new THREE.BoxGeometry( 50, 50, 50);
        let mat = new THREE.MeshBasicMaterial();
        mat.color.setRGB( 1, 0, 0 );
        let cube = new THREE.Mesh( geom, mat );
        cube.position.set(0, -100, -400)
        scene.add( cube );  


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove( event ) {
          mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
          mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }
        

        window.addEventListener( 'mousemove', onMouseMove, false );

        const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 0, 0 );
				scene.add( hemiLight );

        const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( 0, 0, 100 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 180;
				dirLight.shadow.camera.bottom = - 100;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );

        const loader = new FBXLoader();
        loader.load('models/idle.fbx', (object) => {
          object.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          object.position.set(0, -100, -400)
          scene.add(object);
        });
        
        

        animate();


        

        function animate() {
            
            // scene.rotation.y += 0.01; 
            // scene.position.z += 1; 

            // update the picking ray with the camera and mouse position
            raycaster.setFromCamera( mouse, camera );

            // calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects( scene.children );

            for ( let i = 0; i < intersects.length; i ++ ) {
              if (intersects[0].object == cube)
                cube.rotation.y += 0.5
            }
            
            requestAnimationFrame(animate);

            renderer.render(scene,camera);
            
        }




    </script>
  </body>
</html>