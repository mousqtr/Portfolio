<!DOCTYPE html>
<html>
  <head>
    <meta charset=UTF-8 />
    <title>Titre de la page</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <canvas id="c"></canvas>
    
    <script type="module"> 
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
        import {GLTFLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/GLTFLoader.js';
        import {FBXLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/FBXLoader.js';

        let scene, camera, renderer;
        
        const clock = new THREE.Clock();
        let objects = {};
        let actions = {};
        let mixers = {};
        let movement = 0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let positionState = 0;
        
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'click', onClick, false );

        function onWindowResize(){
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );

          if (Object.keys(objects).length > 0){
            let posZ;
            
            // Paladin
            posZ = 0.375 * window.innerWidth - 1150;
            posZ = Math.min(-600, posZ);
            posZ = Math.max(-1000, posZ);
            objects["paladin"].position.set(objects["paladin"].position.x, objects["paladin"].position.y, posZ);
          
            // Door
            posZ = 0.67 * window.innerWidth - 2333;
            objects["door"].position.set(objects["door"].position.x, objects["door"].position.y, posZ);

            // Text above door
            for (let i = 0; i < objects["textsDoor"].length; i++) {
              if (i < 2){
                posZ = 0.67 * window.innerWidth - 2500;
              }else{
                posZ = 0.67 * window.innerWidth - 4500;
              }
              objects["textsDoor"][i].position.set(objects["textsDoor"][i].position.x, objects["textsDoor"][i].position.y, posZ);
            }
            
          }
                  
        }

        const canvas = document.querySelector('#c');

        scene = new THREE.Scene();
        const fov = 55; // field of view
        const aspect = window.innerWidth/window.innerHeight;  // the canvas default
        const near = 45;
        const far = 30000;
        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0,0,0);
        
        renderer = new THREE.WebGLRenderer({antialias:true, canvas});
        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // let controls = new OrbitControls(camera, renderer.domElement );
        // controls.addEventListener('change', renderer);
        // controls.minDistance = 500;
        // controls.maxDistance = 1500;
        
        // Load the corridor
        let corridorMaterialArray = [];
        let texture_ft = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_bk = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_up = new THREE.TextureLoader().load( 'img/wall3.jpg');
        let texture_dn = new THREE.TextureLoader().load( 'img/parquet.jpg');
        let texture_rt = new THREE.TextureLoader().load( 'img/wall2.jpg');
        let texture_lf = new THREE.TextureLoader().load( 'img/wall2.jpg');

        texture_dn.wrapS = texture_dn.wrapT = THREE.RepeatWrapping;
        texture_up.wrapS = texture_up.wrapT = THREE.RepeatWrapping;
        texture_ft.wrapS = texture_ft.wrapT = THREE.RepeatWrapping;
        texture_bk.wrapS = texture_bk.wrapT = THREE.RepeatWrapping;

        texture_dn.repeat.y = 5;
        texture_up.repeat.y = 5;
        texture_ft.repeat.x = 5;
        texture_bk.repeat.x = 5;

        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));
        corridorMaterialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));

        for (let i = 0; i < 6; i++) {
          corridorMaterialArray[i].side = THREE.BackSide;
        }
            
        let corridorGeo = new THREE.BoxGeometry( 1000, 1000, 10000);
        let corridor = new THREE.Mesh( corridorGeo, corridorMaterialArray );
        corridor.position.set(0, 0, -4500)
        scene.add( corridor );  

        // Load the top arrow 
        const arrowLoader = new FBXLoader();
        arrowLoader.load('models/arrow.fbx', (arrow) => {
          arrow.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
            child.material = new THREE.MeshPhongMaterial( { 
              color: 0xffff00
            } );
          });       
          arrow.scale.setScalar(200);
          arrow.position.set(0, 200, -600);
          arrow.rotation.set(-Math.PI/2, Math.PI, Math.PI/2);
          arrow.name = "arrow";
          objects["arrow"] = arrow;
          scene.add(arrow);
        });

        // Get the mouse position
        function onMouseMove( event ) {
          mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
          mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        // When user click somewhere
        function onClick(event) {
          raycaster.setFromCamera( mouse, camera );
          const intersects = raycaster.intersectObjects( scene.children, true );

          for ( let i = 0; i < intersects.length; i ++ ) {
            if ((intersects[0].object.name == 'Box') || (intersects[0].object.name == 'Box1')){
              
              if (Object.keys(objects).length > 1){
                movement = 1;
              }
            }
          }
        }

        // Hemisphere Light
        const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 0, 0 );
				scene.add( hemiLight );

        // Directional Light
        const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( 0, 0, 100 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 180;
				dirLight.shadow.camera.bottom = - 100;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );

        // Load the paladin model
        const loaderPaladin = new FBXLoader();
        loaderPaladin.load('models/paladin/paladin.fbx', (paladin) => {

          // Load the model
          paladin.scale.setScalar(3);
          paladin.position.set(0, -500, -600)
          paladin.rotation.set(0, Math.PI, 0)
          paladin.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          objects["paladin"] = paladin;

          // Load the walk animation
          const animWalk = new FBXLoader();
          animWalk.load('models/paladin/walk.fbx', (animWalk) => {
            const mixer = new THREE.AnimationMixer(paladin);     
            const action = mixer.clipAction( animWalk.animations[0] );
            mixers["mixerWalk"] = mixer
            actions["walk"] = action;
          });
          
          // Load the stand animation
          const animStand = new FBXLoader();
          animStand.load('models/paladin/stand_brief.fbx', (animStand) => {
            const mixer = new THREE.AnimationMixer(paladin);
            const action = mixer.clipAction(animStand.animations[0]);
            mixers["mixerStand"] = mixer
            actions["stand"] = action;
            action.play();
          });

          scene.add(paladin);
        });

        // Load the door model
        const loaderDoor = new FBXLoader();
        loaderDoor.load('models/door.fbx', (door) => {

          door.traverse(child => {
            child.castShadow = true;
            child.receiveShadow = true;
          });
          door.scale.setScalar(0.3);
          let distance_door = 0.67 * window.innerWidth - 2333;
          door.position.set(500, -500, distance_door);
          door.rotation.set(0, Math.PI/2, 0);

          objects["door"] = door;

          scene.add(door);
        });

        // Cube above door
        let cubeTextArray = [];
        let geoText, matText, cubeText, distance_cube;
        let textPosX, textPosZ;
        for ( let i = 0; i < 4; i ++ ) {
          geoText = new THREE.BoxGeometry( 300, 200, 50);
          matText = new THREE.MeshBasicMaterial();
          matText.color.setRGB( 4/255, 47/255, 102/255 );
          cubeText = new THREE.Mesh( geoText, matText );

          if (i % 2 == 0){
            textPosX = -400;
          }else{
            textPosX = 400;
          }

          if (i < 2){
            textPosZ = 0.67 * window.innerWidth - 2500;
          }else{
            textPosZ = 0.67 * window.innerWidth - 4500;
          }

          cubeText.position.set(textPosX, 270, textPosZ)

          cubeTextArray.push(cubeText)

          scene.add(cubeText);  
        }

        
        objects["textsDoor"] = cubeTextArray;
        
        
        animate();

        function animate() {
            
          if (movement == 0){
            raycaster.setFromCamera( mouse, camera );
            const intersects = raycaster.intersectObjects( scene.children, true );
            for ( let i = 0; i < intersects.length; i ++ ) {

              // Case of the upper arrow
              if ((intersects[0].object.name == 'Box') || (intersects[0].object.name == 'Box1')){
                
                // Change the color of the arrow into red
                if (Object.keys(objects).length > 1){
                  objects["arrow"].traverse(function(child){
                    child.material = new THREE.MeshPhongMaterial( { 
                      color: 0xff0000
                    }); 
                  });
                }

              }else{
                
                // Change the color of the arrow into yellow
                if (Object.keys(objects).length > 1){
                  objects["arrow"].traverse(function(child){
                    child.material = new THREE.MeshPhongMaterial( { 
                      color: 0xffff00
                    }); 
                  });
                } 
              }
            }
          }

          // Walking from the first position
          if ((movement == 1) && (positionState == 0)){

            // Gradually move the character
            objects["paladin"].position.z -= 10;

            // Run the walk animation
            if (Object.keys(actions).length > 1){
              if(actions["stand"].isRunning()){
                actions["stand"].stop();
                actions["walk"].play();
              }
            }

            // Gradually move the camera
            camera.position.z -= 10;
          }

          // Stop walking at the second position
          if ((movement == 1) && (objects["paladin"].position.z < -2500) && (positionState == 0)){

            // Stop the walk animation
            if (Object.keys(actions).length > 1){
              if(actions["walk"].isRunning()){
                actions["walk"].stop();
                actions["stand"].play();
              }
            }

            // Change the walk flag
            movement = 0;

            // Change the position flag
            positionState = 1

            // Move and turn the arrow
            objects["arrow"].position.set(objects["arrow"].position.x, objects["arrow"].position.y, -2600)
            objects["arrow"].rotation.set(Math.PI/2, Math.PI, Math.PI/2)

          } 


          // Walking from the second position
          if ((movement == 1) && (positionState == 1)){

            // Gradually move the character
            objects["paladin"].position.z += 10;

            // Run the walk animation
            if (Object.keys(actions).length > 1){
              if(actions["stand"].isRunning()){
                actions["stand"].stop();
                actions["walk"].play();
              }
            }

            // Gradually move the camera
            camera.position.z += 10;
          }


          // Stop walking at first position
          if ((movement == 1) && (objects["paladin"].position.z > -600) && (positionState == 1)){

            // Stop the walk animation
            if (Object.keys(actions).length > 1){
              if(actions["walk"].isRunning()){
                actions["walk"].stop();
                actions["stand"].play();
              }
            }

            // Change the walk flag
            movement = 0;

            // Change the position flag
            positionState = 0

            // Move and turn the arrow
            objects["arrow"].position.set(objects["arrow"].position.x, objects["arrow"].position.y, -600)
            objects["arrow"].rotation.set(-Math.PI/2, Math.PI, Math.PI/2)

          } 




          const delta = clock.getDelta();

          if ( mixers["mixerWalk"] ) mixers["mixerWalk"].update( delta );
          if ( mixers["mixerStand"] ) mixers["mixerStand"].update( delta );
    
          requestAnimationFrame(animate);

          renderer.render(scene,camera);
            
        }


    </script>
  </body>
</html>